# -*- coding: utf-8 -*-
board_size = 11  # 棋盘大小
buffer_size = 12000  # 棋盘越大，这个数字就得越大，每局棋约30步，则可以保存400局棋。这个数字貌似还得适当调大一点
simulation_per_step = 542  # 对于初始棋盘格点数121，每个至少访问2次，花销242,。还剩300次自由访问机会，alphago是1600
upper_simulation_per_step = 642  # 有些节点作为非根节点已经被访问过。那么合计最多访问这么多次了算了，节约点时间
goal = 5  # 五子棋，故为5
batch_size = 512
# 学习率下降方案，貌似第一个7000还可以继续调大，即以1e-3的学习率需要学习更长时间
lr_ = [(7000, 1e-3), (14000, 2e-4), (28000, 4e-5), (100000000, 2e-6)]
ckpt_path = "ckpt"
total_step = 20000  # 预设定的学习步数。我只学习到8k左右就掐断了，电脑太水了跑的太慢了。
tau_decay_rate = 0.94  # 温度衰减项，越往后温度应该越低
# 这个温度是为了选择最佳ckpt的时候使用。在人机对弈的时候，AI是决定性落子。
# 但是在比较两个ckpt的优劣的时候，就不能决定性落子。这个温度比tau_decay_rate，表示不需要深度探索了。
tau_decay_rate_r = 0.9
c_puct = 5.0  # 这个数调大一点。
dirichlet_alpha = 0.3  # 这个值越大，产生的分布越均匀，棋盘越大，这个值也相应稍微调小点为好
gamma = 0.94  # 权重衰减因子，越是后面的局面，出现的频率就越低，分配的训练权重越大。反过来分配的。。
init_temp = 1.2  # 初始温度  # 温度越大分布越平缓，这里适当调大，主要是考虑到初始分布太尖锐了
max_processes = 5   # 并行产生数据的进程数。时间主要消耗在了生成数据上，这个数值在电脑运行范围内适当调大为好。


def get_lr(step):
    for item in lr_:
        if step < item[0]:
            return item[1]
    return lr_[-1][-1]
